<!doctype html>
<!--
  ============================================================================
  File:      11-05_minilab5-intro.html
  Project:   Understanding Infection Dynamics · Infektionsdynamiken verstehen
  Type:      Open Educational Resource (OER)
  Authors:   B. D. Rausch · A. Heinz
  License:   CC BY 4.0

  Created:   2025-09-26
  Updated:   2025-09-26
  Version:   3.0.5
  Changelog: - v3.0.5 Dauerfix Schwarzbild: onParams() direkt nach Mount
             - v3.0.4 Diagnose-Script (temporär, jetzt entfernt)
             - v3.0.2 GridWave unter p.lead (ESM Import-Map, Controls)
             - v3.0.0 SIRV-Demo (ohne Boot); KPI-Decks angepasst
  ============================================================================
-->
<html lang="de" data-mode="school" data-page="repo" data-model="SIR" data-coach="ben">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Infektionsdynamiken – Repository · Minilab 5 Intro (SIRV)</title>

    <!-- Core Styles -->
    <link rel="stylesheet" href="../css/tokens.css" />
    <link rel="stylesheet" href="../css/base.css" />
    <link rel="stylesheet" href="../css/layout.css" />
    <link rel="stylesheet" href="../css/components.css" />
    <link rel="stylesheet" href="../css/patterns.css" />
    <link rel="stylesheet" href="../css/pages.css" />
    <link rel="stylesheet" href="../css/landing.css" />

    <style>
      /* Header: Navigation bei kleinen Viewports einkürzen */
      @media (max-width: 1000px) { .landing-header .nav-links { display: none; } }
      .wordmark-short { display: none; }
      @media (max-width: 680px) { .wordmark-long { display: none; } .wordmark-short { display: block; } }
      @media (max-width: 499.98px) { .wordmark-long, .wordmark-short { display: none; } }

      /* Demo-Stage innerhalb der Card */
      .demo-stage { display: grid; gap: 16px; }
      .chart-wrap { border-radius: 12px; border: 1px solid var(--border, #e5e7eb); background: var(--panel, #fff); overflow: hidden; min-height: 360px; }
      .chart-wrap canvas { display: block; width: 100%; height: 420px; }

      .deck { display: grid; gap: 14px; margin-top: 12px; }
      .deck-comp    { grid-template-columns: repeat(3, minmax(0, 1fr)); }  /* S, I, R */
      .deck-context { grid-template-columns: repeat(2, minmax(0, 1fr)); }  /* t, V */
      @media (max-width: 820px) {
        .deck-comp, .deck-context { grid-template-columns: 1fr; }
      }

      .kpi-pill {
        border-radius: 16px;
        border: 1px solid var(--shadow, #e5e7eb);
        background: var(--bg, #fff);
        padding: 12px 14px;
        box-shadow: var(--shadow-sm, 0 1px 2px rgba(0,0,0,.04));
      }
      .kpi-pill strong { display: block; font-weight: 600; margin-bottom: 6px; }
      .kpi-pill .val { font-size: 1.1rem; line-height: 1.2; }

      /* Farbbindung an Tokens */
      .kpi-pill.s { border-left: 4px solid var(--c-s, #22c55e); } /* Susceptible */
      .kpi-pill.i { border-left: 4px solid var(--c-i, #ef4444); } /* Infectious  */
      .kpi-pill.r { border-left: 4px solid var(--c-r, #3b82f6); } /* Recovered   */
      .kpi-pill.v { border-left: 4px solid var(--c-v, #8b5cf6); } /* Vaccinated  */

      /* Ergänzungen für GridWave-Section */
      .row { display: grid; grid-template-columns: 1fr 320px; gap: 16px; align-items: start; }
      @media (max-width: 900px) { .row { grid-template-columns: 1fr; } }

      #uidg { background: #000; border-radius: 12px; overflow: hidden; aspect-ratio: 1/1; }
      .card.controls { background: var(--panel, #1c1c1e); color: var(--text, #111); border-radius: 12px; padding: 12px; }

      .gridrow { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
      .gridrow label { display: block; font-size: 12px; opacity: .85; }

      button { padding: 8px 12px; border-radius: 8px; border: 0; background: #2d2d2f; color: #fff; cursor: pointer; }
      input[type="range"] { width: 100%; }
      small { opacity: .7; }
    </style>

    <!-- Import-Map (ESM) – exakter Pfad, Leerzeichen/Klammern kodiert -->
    <script type="importmap">
    {
      "imports": {
        "uid-g": "../1_architecture/1-2%20UID-E%20%28Minilab%20Explore%29/12-3%20Presentation%20layer/12-34%20Grid/index.js"
      }
    }
    </script>
  </head>

  <body id="top" class="repo">
    <!-- Header -->
    <header class="landing-header" role="banner">
      <div class="container bar">
        <a class="brand" href="../index.html" aria-label="Infektionsdynamiken.de — Startseite">
          <div class="wordmark wordmark-long">
            <div class="brand-title">Infektionsdynamiken verstehen</div>
            <div class="brand-claim">Repository · transparent &amp; zugänglich</div>
          </div>
          <div class="wordmark wordmark-short">
            <div class="brand-title">Infektionsdynamiken.de</div>
            <div class="brand-claim">Repository</div>
          </div>
        </a>
        <nav class="landing-nav" aria-label="Hauptnavigation Repository">
          <div class="nav-links">
            <a href="../architektur.html">Architektur</a>
            <a href="../publikationen.html">Publikationen</a>
            <a href="../lehre.html">Lehre</a>
            <a href="https://infektionsdynamiken.de/#legal">Rechtliches</a>
          </div>
        </nav>
      </div>
    </header>

    <main>
      <section class="section container">
        <article class="card pad">
          <span class="eyebrow">DEMO</span>
          <hr class="accent-line" />
          <h1>UID-Explore: Gridwave (Presentation)</h1>
          <p class="lead">Dummy zur Wellenvisualisierung</p>

          <div class="demo-stage">
            <div class="chart-wrap">
              <div class="row">
                <div id="uidg" aria-label="Rastervisualisierung der Modellanteile"></div>

                <div class="card controls" aria-label="Darstellungsoptionen">
                  <div style="display: flex; gap: 8px; margin-bottom: 8px;">
                    <button id="btnPlay">Play</button>
                    <button id="btnStop">Stop</button>
                    <select id="mode" aria-label="Modus">
                      <option value="proportional">Proportional</option>
                      <option value="wave">Wave</option>
                      <option value="cluster">Cluster</option>
                      <option value="hybrid" selected>Hybrid</option>
                    </select>
                  </div>

                  <div class="gridrow" style="margin-bottom: 8px;">
                    <div>
                      <label>Hybrid d₀
                        <input id="d0" type="range" min="0" max="0.6" step="0.01" value="0.25" />
                      </label>
                    </div>
                    <div>
                      <label>Hybrid p
                        <input id="p" type="range" min="1" max="4" step="0.1" value="2" />
                      </label>
                    </div>
                  </div>

                  <label>t Index
                    <input id="t" type="range" min="0" max="199" step="1" value="0" />
                  </label>
                  <div style="display: flex; justify-content: space-between;">
                    <small>0</small><small id="tval">0</small><small>199</small>
                  </div>

                  <p><small>Farben über gemeinsame Farbdefinitionen: <code>--c-s</code>, <code>--c-i</code>, <code>--c-r</code>, optional <code>--c-e</code>, <code>--c-v</code>.</small></p>
                  <p><small>Grid: <span id="gridInfo">—</span></small></p>
                </div>
              </div>
            </div>

            <div id="kpis-comp" class="deck deck-comp" aria-label="Kompartimente"></div>
            <div id="kpis-context" class="deck deck-context" aria-label="Kontext-KPIs"></div>
          </div>
        </article>
      </section>
    </main>

    <footer class="landing-footer">
      <div class="container">
        <p class="muted">© CC BY 4.0 · Infektionsdynamiken – Repository (Preview). Keine Cookies.</p>
      </div>
    </footer>

    <!-- ===== GridWave Mount (ESM via Import-Map) – ohne Runner ===== -->
  <script type="module">
      import { mountGridWidget, destroyGridWidget } from "uid-g";

      const container = document.getElementById("uidg");
      const gridInfo  = document.getElementById("gridInfo");
      const modeSel   = document.getElementById("mode");
      const d0Input   = document.getElementById("d0");
      const pInput    = document.getElementById("p");
      const rng       = document.getElementById("t");
      const tval      = document.getElementById("tval");
      const btnPlay   = document.getElementById("btnPlay");
      const btnStop   = document.getElementById("btnStop");

      function computeGridForContainer(el, targetPx = 7, min = 40, max = 128) {
        const rect = el.getBoundingClientRect();
        const side = Math.min(rect.width, rect.height);
        const dpr  = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
        const logicalSide = side * dpr;
        const g = Math.round(logicalSide / targetPx);
        return Math.max(min, Math.min(max, g));
      }

      // einfache SIR-Serie für die Demo (ersetzt Runner)
      function genSIRSeries(L = 200) {
        const S = new Array(L), I = new Array(L), R = new Array(L);
        let s = 0.999, i = 0.001, r = 0;
        const beta = 0.35, gamma = 0.08, dt = 1;
        for (let k = 0; k < L; k++) {
          S[k] = s; I[k] = i; R[k] = r;
          const ds = -beta * s * i * dt;
          const di = (beta * s * i - gamma * i) * dt;
          const dr =  gamma * i * dt;
          s = Math.max(0, s + ds);
          i = Math.max(0, i + di);
          r = Math.min(1, 1 - s - i);
        }
        return { t: Array.from({ length: L }, (_, k) => k), series: { S, I, R } };
      }

      let gw = null;
      let sim = genSIRSeries(200);
      let playTimer = 0;

      function mountWithGrid(grid, mode) {
        const idx = rng.value | 0;
        const hybrid = { d0: parseFloat(d0Input.value), p: parseFloat(pInput.value), blurPasses: 2 };

        if (gw) destroyGridWidget(gw);
        gw = mountGridWidget({ el: container, grid, mode, animate: true, hybrid });

        // **Pflicht**: Ranking/Seed initialisieren – sonst bleibt das Canvas schwarz
        gw.onParams({
          simId: `demo-seed-${grid}-${mode}`,
          mode: (document.documentElement.dataset.mode === "school") ? "school" : "university"
        });

        // Erstes Bild aus Demo-Serie zeichnen
        pushFrame(idx);

        if (gridInfo) gridInfo.textContent = `${grid} × ${grid} = ${(grid * grid).toLocaleString()}`;
      }

      function pushFrame(idx) {
        const S = sim.series.S[idx], I = sim.series.I[idx], R = sim.series.R[idx];
        gw.onUpdate({ idx, proportions: { S, I, R, V: 0 } });
        if (tval) tval.textContent = String(idx);
      }

      // Initial mount
      const initialGrid = computeGridForContainer(container, 7, 40, 128);
      const initialMode = (document.documentElement.dataset.mode === "school") ? "cluster" : "hybrid";
      mountWithGrid(initialGrid, initialMode);

      // Controls
      modeSel.addEventListener("change", () => {
        const grid = computeGridForContainer(container, 7, 40, 128);
        mountWithGrid(grid, modeSel.value);
      });

      d0Input.addEventListener("input", () => {
        if (modeSel.value !== "hybrid") return;
        const grid = computeGridForContainer(container, 7, 40, 128);
        mountWithGrid(grid, modeSel.value);
      });

      pInput.addEventListener("input", () => {
        if (modeSel.value !== "hybrid") return;
        const grid = computeGridForContainer(container, 7, 40, 128);
        mountWithGrid(grid, modeSel.value);
      });

      rng.addEventListener("input", () => {
        const idx = rng.value | 0;
        pushFrame(idx);
      });

      btnPlay.addEventListener("click", () => {
        clearInterval(playTimer);
        playTimer = setInterval(() => {
          let idx = (rng.value | 0) + 1;
          if (idx > (sim.t.length - 1)) idx = 0;
          rng.value = String(idx);
          pushFrame(idx);
        }, 80);
      });

      btnStop.addEventListener("click", () => clearInterval(playTimer));

      // Remount bei Resize
      let rt = 0;
      const ro = new ResizeObserver(() => {
        clearTimeout(rt);
        rt = setTimeout(() => {
          const grid = computeGridForContainer(container, 7, 40, 128);
          mountWithGrid(grid, modeSel.value);
        }, 120);
      });
      ro.observe(container);
    </script>
</body>
</html>

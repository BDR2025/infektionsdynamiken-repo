UID-Intro ¬∑ SIS Runner ¬∑ tech.txt
Zweck

Der SIS Runner f√ºhrt die Intro-Simulation f√ºr SIS aus. Er rechnet deterministisch mit festem Integrator Euler, zeichnet die Kurven ins Canvas und liefert pro Tick KPI-Werte. Er w√§hlt anhand von Sprache, Modus und Coach die passende Etappen-Sequenz. Gegen√ºber SIR und SEIR gibt es kein R-Fach, stattdessen stehen S und I im Fokus sowie das endemische Gleichgewicht 
ùêº
\*
I
\*
 und die Zeit bis zur Ann√§herung 
ùë°
95
t
95
	‚Äã

.

Voraussetzungen im DOM
<canvas id="intro-canvas"></canvas>
<!-- Optional bei Betrieb ohne Boot -->
<div id="kpis-comp"></div>
<div id="kpis-context"></div>


Der Kontext steht am <html> Element √ºber lang, data-mode, data-coach. Fehlt data-coach, w√§hlt der Runner automatisch passend zu Sprache und Modus.

Einbindung
Mit Boot
<script type="module">
  import * as Run from "/js/minilabs/intro/intro-sis.js";
  window.mountIntroSIS = Run.mountIntroSIS || Run.default || Run;
</script>
<script src="/js/minilabs/intro/intro-boot.js"></script>


Boot injiziert die KPI-Decks und verdrahtet Replay und Coach.

Ohne Boot
<script type="module">
  import { mountIntroSIS } from "/js/minilabs/intro/intro-sis.js";

  const controller = mountIntroSIS({
    canvas: document.getElementById("intro-canvas"),
    onUpdate: p => {
      // KPI ins UI schreiben
      // z. B. p.t, p.r0, p.reff, p.sRel, p.iRel, p.Istar { value }, p.t95
    },
    // onEnd: () => {}   // optional, im Runner derzeit nicht implementiert
  });

  controller.play();
  // controller.stop();
</script>

API
mountIntroSIS(opts) -> Controller

opts.canvas   // HTMLCanvasElement oder CSS-Selector
opts.onUpdate // Funktion: erh√§lt pro Tick KPI-Payload
opts.onEnd    // optionaler Abschluss-Callback (im Runner aktuell nicht aufgerufen)
opts.locale   // optional: √ºberschreibt <html lang>
opts.mode     // optional: √ºberschreibt data-mode
opts.coach    // optional: √ºberschreibt data-coach

Controller = { play(): void, stop(): void, isRunning(): boolean }

Modell, Numerik und Ablauf

SIS auf Fraktionsskala 
ùëÅ
=
1
N=1

Parameter im Runner: 
ùëÖ
0
R
0
	‚Äã

, 
ùê∑
D (infekti√∂se Dauer), 
ùêº
0
I
0
	‚Äã

, 
ùëá
T (Laufzeit in Tagen), 
ùëë
ùë°
dt

Euler-Integration

ùëÜ
Àô
=
‚àí
ùõΩ
ùëÜ
ùêº
+
ùõæ
ùêº
,
ùêº
Àô
=
ùõΩ
ùëÜ
ùêº
‚àí
ùõæ
ùêº
,
ùõæ
=
1
/
ùê∑
,
¬†
ùõΩ
=
ùëÖ
0
‚ãÖ
ùõæ
S
Àô
=‚àíŒ≤SI+Œ≥I,
I
Àô
=Œ≤SI‚àíŒ≥I,Œ≥=1/D,¬†Œ≤=R
0
	‚Äã

‚ãÖŒ≥

Sequenzen pro Coach steuern Sichtbarkeit, Carry-Over und Resets der Kurven sowie den Zeitpunkt der I*-Freigabe

KPI-Payload (Beispiel)
{
  "t": 120,
  "r0": 1.25,
  "reff": 1.02,
  "sRel": 81.1,
  "iRel": 18.9,
  "Istar": { "value": 20.0 },
  "t95": 360
}


Hinweise

sRel und iRel erscheinen nur, wenn die jeweilige Kurve in der aktuellen Etappe sichtbar ist

Istar.value ist das Gleichgewicht der Erkrankten in Prozent 
ùêº
\*
=
1
‚àí
1
/
ùëÖ
0
I
\*
=1‚àí1/R
0
	‚Äã

 f√ºr 
ùëÖ
0
>
1
R
0
	‚Äã

>1

t95 ist die Zeit bis 95 Prozent Ann√§herung an 
ùêº
\*
I
\*

Zus√§tzlich sendet der Runner pro Tick ein Window-Event:

window.addEventListener("idv:intro:kpi", e => {
  const p = e.detail;
});

Rendering

Canvas-Rendering ohne Chart-Bibliothek

Farben aus CSS-Tokens, √ºblicherweise --c-s und --c-i

Gitterlinien auf Prozentrastern

Marker

I* als horizontale gestrichelte Linie mit Label

t95 als vertikale gestrichelte Linie mit Label

Timing

Zeitsteuerung via requestAnimationFrame

Aktuelle Runner-Version: FPS-gebundenes Fortschreiben idx += speed/60

Optionales Upgrade auf rAF-Delta m√∂glich, die API bleibt unver√§ndert

Coach-Varianten in einem Runner

Der Runner liest lang, data-mode und data-coach und w√§hlt damit die Sequenz. Die Sequenzen definieren Etappen, Dauer, sichtbare Kurven, Carry-Over und Resets. Separate Dateien sind nicht erforderlich.

H√§ufige Fehlerquellen

Falscher Modulpfad beim Import

Canvas hat keine CSS-Gr√∂√üe und rendert daher 0√ó0

onUpdate fehlt beim Betrieb ohne Boot, dadurch keine KPI-Anzeige im UI

Mehrfaches Mounten ohne Cleanup kann doppelte Window-Listener erzeugen

Minimaldiagnose

Nach controller.play() controller.isRunning() pr√ºfen

Auf idv:intro:kpi lauschen und Payload loggen

canvas.width/height und CSS-Gr√∂√üe vergleichen

Boot-Abgleich f√ºr SIS

Damit Boot und Runner zusammenarbeiten

KPI-Rezept im Boot: oben S, I, unten t, Istar, t95

IDs im Boot-Deck: #kpi-s-rel, #kpi-i-rel, #kpi-t, #kpi-Istar, #kpi-t95

Beispiel-Mapping im Boot

if (k === "Istar" && detail.Istar) setText("#kpi-Istar", `${detail.Istar.value.toFixed(1)} %`);
if (k === "t95"   && detail.t95 != null) setText("#kpi-t95", String(detail.t95));


Mount-Kontrakt: Boot ruft mount({ canvas: "#intro-canvas", onUpdate }) auf und steuert Start und Replay √ºber play() und stop()